//! Build script for fs-wrapper
//!
//! Scans FS_WRAPPER_PACK_DIR (or ./pack) for files and generates
//! Rust code to embed them via include_bytes!

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let pack_dir = env::var("FS_WRAPPER_PACK_DIR").unwrap_or_else(|_| "pack".into());
    let pack_path = Path::new(&pack_dir);

    println!("cargo::rerun-if-env-changed=FS_WRAPPER_PACK_DIR");

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_files.rs");

    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs - do not edit\n\n");
    code.push_str("pub static FILES: &[(&str, &[u8])] = &[\n");

    if pack_path.exists() && pack_path.is_dir() {
        let mut entries: Vec<_> = fs::read_dir(pack_path)
            .expect("failed to read pack directory")
            .filter_map(|e| e.ok())
            .filter(|e| e.path().is_file())
            .collect();

        // Sort for deterministic builds
        entries.sort_by_key(|e| e.file_name());

        for entry in entries {
            let path = entry.path();
            let name = path.file_name().unwrap().to_str().unwrap();
            let abs_path = fs::canonicalize(&path).expect("failed to canonicalize path");

            println!("cargo::rerun-if-changed={}", abs_path.display());

            code.push_str(&format!(
                "    (\"{}\", include_bytes!(\"{}\")),\n",
                name,
                abs_path.display()
            ));
        }
    } else {
        // No pack directory - emit warning but allow build with empty FILES
        println!("cargo::warning=FS_WRAPPER_PACK_DIR '{}' not found or not a directory. Building with no embedded files.", pack_dir);
    }

    code.push_str("];\n");

    fs::write(&dest_path, code).expect("failed to write generated code");
}
